#!/usr/bin/python -Es
from __future__ import print_function
import argparse
import functools
import os
import platform
import re
import subprocess
import sys
import textwrap

try:
    from configparser import ConfigParser
except ImportError:
    from ConfigParser import ConfigParser

from toolforge.webservice import WebService
from toolforge.webservice.backends import (
    Backend,
    GridEngineBackend,
    KubernetesBackend,
)
from toolforge.common.utils import wait_for
from toolforge.common import Tool


BACKEND_DEFAULT = "kubernetes"
GRIDENGINE_DEFAULT_TYPE = "lighttpd"
KUBERNETES_DEFAULT_TYPE = "php7.3"

# Make all `print()` output go to stderr by default
print = functools.partial(print, file=sys.stderr)


def format_types_block(config, default, leader="\n  * "):
    """Pretty print a list of runtime types for a backend."""
    types = []
    for name, spec in config.items():
        extra = ""
        if name == default:
            extra = " (default)"
        elif spec.get("deprecated", False):
            extra = " (DEPRECATED)"
        types.append("{}{}".format(name, extra))
    return leader.join(sorted(types))


def kube_quant(string):
    """
    A type for args that roughly matches up with Kubernetes' quantity.go
    General form is <number><suffix>
    The following are acceptable suffixes

    base1024: Ki | Mi | Gi | Ti | Pi | Ei
    base1000: n | u | m | "" | k | M | G | T | P | E
    """
    valid_suffixes = [
        "Ki",
        "Mi",
        "Gi",
        "Ti",
        "Pi",
        "Ei",
        "n",
        "u",
        "m",
        "",
        "k",
        "M",
        "G",
        "T",
        "P",
        "E",
    ]
    pattern = re.compile(r"^(\d+)([A-Za-z]{0,2})$")
    quant_check = pattern.match(string)
    if quant_check:
        suffix = quant_check.group(2)
        if suffix in valid_suffixes:
            return string

    msg = "{} is not a valid Kubernetes quantity".format(string)
    raise argparse.ArgumentTypeError(msg)


def start(job, message):
    try:
        job.request_start()
    except WebService.InvalidWebServiceException as e:
        raise SystemExit(e.message)
    # FIXME: Treat pending state differently.
    return wait_for(lambda: job.get_state() == Backend.STATE_RUNNING, message)


def stop(job, message):
    job.request_stop()
    return wait_for(lambda: job.get_state() == Backend.STATE_STOPPED, message)


def update_manifest(job, action, cpu, memory):
    """
    Update a tool's service manifest to indicate the type of webservice in use

    :param action 'start' or 'stop'
    :param cpu persists the cpu argument (must be a kube_quant)
    :param memory persists the mem argument (must be a kube_quant)
    """
    if action == "start":
        if (
            "web" not in job.tool.manifest
            or job.tool.manifest["web"] != job.type
        ):
            job.tool.manifest["distribution"] = platform.linux_distribution()[
                0
            ]
            job.tool.manifest["web"] = job.type
            if job.extra_args:
                job.tool.manifest["web::extra_args"] = job.extra_args

            if hasattr(job, "container_resources"):
                # Not using the value directly to avoid persisting values from
                # the old Kubernetes cluster
                if cpu is not None:
                    job.tool.manifest["cpu"] = cpu
                if memory is not None:
                    job.tool.manifest["memory"] = memory

            job.tool.save_manifest()
    elif action == "stop":
        if "web" in job.tool.manifest:
            for key in [
                "distribution",
                "web",
                "backend",
                "cpu",
                "memory",
                "web::extra_args",
            ]:
                if key in job.tool.manifest:
                    del job.tool.manifest[key]
            job.tool.save_manifest()
    else:
        # blow up!
        raise Exception("action has to be 'start' or 'stop', got %s" % action)


if __name__ == "__main__":
    description = """
    Online documentation: https://wikitech.wikimedia.org/wiki/Help:Toolforge/Web

    Supported webservice types:
      Kubernetes backend:
        * {kubernetes}
      Grid Engine backend:
        * {gridengine}
    """.format(
        kubernetes=format_types_block(
            KubernetesBackend.CONFIG,
            KUBERNETES_DEFAULT_TYPE,
            leader="\n        * ",
        ),
        gridengine=format_types_block(
            GridEngineBackend.CONFIG,
            GRIDENGINE_DEFAULT_TYPE,
            leader="\n        * ",
        ),
    )

    argparser = argparse.ArgumentParser(
        description=textwrap.dedent(description),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    argparser.add_argument(
        "--backend",
        help="Which cluster backend to use run the webservice",
        choices=["gridengine", "kubernetes"],
    )
    argparser.add_argument(
        "type", help="Type of webservice to start", nargs="?"
    )

    argparser.add_argument(
        "action",
        help="Action to perform",
        choices=["start", "stop", "status", "restart", "shell"],
    )
    argparser.add_argument(
        "extra_args",
        help="Extra arguments to be parsed by the chosen webservicetype",
        nargs="*",
    )
    # Backwards compat with older webservice.
    # Allows for webservice --release trusty lighttpd <action>
    argparser.add_argument(
        "--release", help=argparse.SUPPRESS, choices=["trusty"]
    )

    k8s_group = argparser.add_argument_group("Kubernetes backend options")
    k8s_group.add_argument(
        "-m",
        "--mem",
        required=False,
        type=kube_quant,
        help="Set higher Kubernetes memory limit",
        dest="memory",
    )
    k8s_group.add_argument(
        "-c",
        "--cpu",
        required=False,
        type=kube_quant,
        help="Set a higher Kubernetes cpu limit",
        dest="cpu",
    )

    args = argparser.parse_args()

    tool = Tool.from_currentuser()

    # In order to more fully enable toolsbeta, we need to know we are there.
    if os.path.isfile("/etc/wmcs-project"):
        with open("/etc/wmcs-project") as f:
            project = f.readline().rstrip()

    # We use this logic rather than setting defaults in argparse.
    # This allows us to default to spec in service.manifest but override
    # by specifying --backend option on the CLI
    rc_backend = None
    webservicerc = os.path.expanduser("~/.webservicerc")
    if os.path.exists(webservicerc):
        config = ConfigParser()
        config.read(webservicerc)
        try:
            rc_backend = config.get("Default", "--backend")
        except ConfigParser.Error as e:
            print("Error reading {}: {}".format(webservicerc, e))

    # Select the first of:
    # * --backend=... from cli args
    # * 'backend' from service.manifest
    # * --backend=... from ~/.webservicerc
    backend = args.backend
    if backend is None:
        backend = tool.manifest.get("backend", rc_backend)

    if backend is None:
        print("WARNING: No explict backend provided.")
        print("  Using default of '{}'".format(BACKEND_DEFAULT))
        print(
            "  For help refer to <https://wikitech.wikimedia.org/wiki/Help:Toolforge/Web>"
        )
        backend = BACKEND_DEFAULT

    if args.action != "shell":
        if "backend" in tool.manifest and tool.manifest["backend"] != backend:
            manifest_file = tool.get_homedir_subpath("service.manifest")
            print(
                "Backend '{}' from {} does not match '{}'".format(
                    tool.manifest["backend"], manifest_file, backend,
                )
            )
            print("  Try stopping your current webservice:")
            print("    webservice stop")
            print("  Then try starting it again:")
            print("    {}".format(" ".join(sys.argv)))
            print(
                "  If you have already tried that and it did not help, "
                "remove the state file before retrying:"
            )
            print("    rm {}".format(manifest_file))
            sys.exit(1)

    if backend == "gridengine":
        # Backwards compatibility hack to support
        # 'webservice --release trusty lighttpd start' invocations
        if args.release is not None:
            print("--release is deprecated and has no effect")
        if args.memory is not None:
            print("--mem is only for --backend=kubernetes")
            print("Please run again without this argument")
            sys.exit(1)
        if args.cpu is not None:
            print("--cpu is only for --backend=kubernetes")
            print("Please run again without this argument")
            sys.exit(1)
        if args.type is None:
            args.type = tool.manifest.get("web", GRIDENGINE_DEFAULT_TYPE)
        acceptable_types = GridEngineBackend.CONFIG
    elif backend == "kubernetes":
        if args.release is not None:
            print("--release is not implemented for --backend=kubernetes")
            print("Please just pick an appropriate type instead")
            sys.exit(1)
        if args.type is None:
            args.type = tool.manifest.get("web", KUBERNETES_DEFAULT_TYPE)

        if args.cpu is None:
            args.cpu = tool.manifest.get("cpu", None)

        if args.memory is None:
            args.memory = tool.manifest.get("memory", None)

        acceptable_types = KubernetesBackend.CONFIG

    if not args.extra_args:
        args.extra_args = tool.manifest.get("web::extra_args", None)

    if args.type not in acceptable_types.keys():
        print("type must be one of:")
        print(format_types_block(acceptable_types, ""))
        sys.exit(1)

    if backend == "gridengine":
        job = GridEngineBackend(tool, args.type, args.extra_args)
    else:
        job = KubernetesBackend(
            tool, project, args.type, args.memory, args.cpu, args.extra_args
        )

    tool.manifest["backend"] = backend

    if job.is_deprecated(args.type):
        print("DEPRECATED: '{}' type is deprecated.".format(args.type))
        print(
            "  See https://wikitech.wikimedia.org/wiki/Help:Toolforge/{}".format(
                "Kubernetes" if backend == "kubernetes" else "Web"
            )
        )
        print("  for currently supported types.")

    if args.action == "start":
        if job.get_state() != Backend.STATE_STOPPED:
            print("Your job is already running")
            sys.exit(1)

        start(job, "Starting webservice")
        update_manifest(job, "start", args.cpu, args.memory)

    elif args.action == "stop":
        if job.get_state() == Backend.STATE_STOPPED:
            print("Your webservice is not running", file=sys.stdout)
        else:
            stop(job, "Stopping webservice")
        update_manifest(job, "stop", args.cpu, args.memory)

    elif args.action == "restart":
        if job.get_state() != Backend.STATE_RUNNING:
            start(job, "Your job is not running, starting")
            update_manifest(job, "start", args.cpu, args.memory)
        else:
            job.request_restart()
        tool.save_manifest()

    elif args.action == "status":
        if job.get_state() != Backend.STATE_STOPPED:
            print(
                "Your webservice of type {} is running on backend {}".format(
                    job.type, backend
                ),
                file=sys.stdout,
            )
        else:
            print("Your webservice is not running", file=sys.stdout)

    elif args.action == "shell":
        if backend != "kubernetes":
            print("ERROR: shell is only supported for kubernetes backend")
            sys.exit(1)
        job.shell()
