#!/usr/bin/python
from __future__ import print_function
import argparse
import sys

from toollabs.webservice import WebService
from toollabs.webservice.backends import Backend, GridEngineBackend, KubernetesBackend
from toollabs.common.utils import wait_for
from toollabs.common import Tool
from toollabs.common.el import log_command_invocation


argparser = argparse.ArgumentParser()
argparser.add_argument('type', help='Type of webservice to start',
                       nargs='?')
argparser.add_argument('--backend', help='Which cluster backend to use run the webservice',
                       choices=['gridengine', 'kubernetes'])
argparser.add_argument('action', help='Action to perform',
                       choices=['start', 'stop', 'status', 'restart'])
argparser.add_argument('extra_args', help='Extra arguments to be parsed by the chosen webservicetype',
                       nargs='?')
# Backwards compat with older webservice. Allows for webservice --release precise lighttpd <action>
argparser.add_argument('--release',
                       help=argparse.SUPPRESS,
                       choices=['precise', 'trusty'])


def start(job, message):
    try:
        job.request_start()
    except WebService.InvalidWebServiceException as e:
        raise SystemExit(e.message)
    # FIXME: Treat pending state differently.
    wait_for(lambda: job.get_state() != Backend.STATE_RUNNING, message)


def stop(job, message):
    job.request_stop()
    wait_for(lambda: not job.get_state() == Backend.STATE_STOPPED, message)

def update_manifest(job, action):
    """
    Update a tool's service manifest to indicate this type of webservice is being used

    :param action 'start' or 'stop', to say if this is an update for a 'start' or 'stop' action
    """
    if action == 'start':
        if 'web' not in job.tool.manifest or job.tool.manifest['web'] != job.type:
            job.tool.manifest['web'] = job.type
            job.tool.save_manifest()
    elif action == 'stop':
        if 'web' in job.tool.manifest:
            del job.tool.manifest['web']
            job.tool.save_manifest()
    else:
        # blow up!
        raise Exception("action has to be 'start' or 'stop', got %s" % action)

if __name__ == '__main__':
    log_command_invocation('webservice', ' '.join(sys.argv))
    args = argparser.parse_args()

    tool = Tool.from_currentuser()
    if args.type is None:
        args.type = tool.manifest.get('web', 'lighttpd')

    # We use this logic rather than setting defaults in argparse.
    # This allows us to default to spec in service.manifest but override
    # by specifying --backend option on the CLI
    if args.backend is None:
        backend = tool.manifest.get('backend', 'gridengine')
    else:
        backend = args.backend

    if backend == 'gridengine':
        # Backwards compatibility hack to support 'webservice --release precise lighttpd start' invocations
        if args.release is not None:
            if args.type == 'lighttpd':
                if args.release == 'precise':
                    args.type = 'lighttpd-precise'
                    print("--release=precise is deprecated. Use %s lighttpd-precise <action> instead" % sys.argv[0])
                elif args.release == 'trusty':
                    print("--release=trusty is deprecated. Use %s %s <action> instead " % sys.argv[0], args.type)
            else:
                print("--release is deprecated and has no effect, using trusty...")
                args.release = 'trusty'
        acceptable_types = GridEngineBackend.CONFIG.keys()
    elif backend == 'kubernetes':
        if args.release is not None:
            print("--release is not implemented for --backend=kubernetes")
            print("Please just pick an appropriate type instead")
            sys.exit(1)
        if args.type is None:
            args.type = tool.manifest.get('web', 'php5.6')
        acceptable_types = KubernetesBackend.CONFIG.keys()

    
    if args.type not in acceptable_types:
        print("type must be one of ", ','.join(acceptable_types))
        sys.exit(1)

    if backend == 'gridengine':
        job = GridEngineBackend(tool, args.type, args.extra_args)
    else:
        job = KubernetesBackend(tool, args.type, args.extra_args)

    tool.manifest['backend'] = backend

    if args.action == 'start':
        if job.get_state() != Backend.STATE_STOPPED:
            print('Your job is already running')
            sys.exit()

        start(job, 'Starting webservice')
        update_manifest(job, 'start')

    elif args.action == 'stop':
        if job.get_state() == Backend.STATE_STOPPED:
            print('Your webservice is not running')
            sys.exit()

        stop(job, 'Stopping webservice')
        update_manifest(job, 'stop')

    elif args.action == 'restart':
        if job.get_state() != Backend.STATE_STOPPED:
            start(job, 'Your job is not running, starting')
        else:
            stop(job, 'Restarting webservice')
            start(job, '')
        tool.save_manifest()
    elif args.action == 'status':
        if job.get_state() != Backend.STATE_STOPPED:
            print('Your webservice is running', end='')
        else:
            print('Your webservice is not running', end='')
    print()  # End program with newline, don't output newline anywhere else :)
