#!/usr/bin/python -Es
from __future__ import print_function
import argparse
try:
    from configparser import ConfigParser
except ImportError:
    from ConfigParser import ConfigParser
import functools
import os
import platform
import re
import sys

from toolforge.webservice import WebService
from toolforge.webservice.backends import (
    Backend,
    GridEngineBackend,
    KubernetesBackend,
)
from toolforge.common.utils import wait_for
from toolforge.common import Tool


GRIDENGINE_DEFAULT_TYPE = "lighttpd"
KUBERNETES_DEFAULT_TYPE = "php5.6"

# Make all `print()` output go to stderr by default
print = functools.partial(print, file=sys.stderr)

def format_types_block(config, default):
    types = []
    for name, spec in config.items():
        extra = ""
        if name == default:
            extra = " (default)"
        elif spec.get("deprecated", False):
            extra = " (DEPRECATED)"
        types.append("{}{}".format(name, extra))
    return "\n  * ".join(sorted(types))


description = """
Online documentation: https://wikitech.wikimedia.org/wiki/Help:Toolforge/Web

Supported webservice types:
Kubernetes backend:
  * {kubernetes}
Grid Engine backend:
  * {gridengine}
""".format(
    kubernetes=format_types_block(
        KubernetesBackend.CONFIG, KUBERNETES_DEFAULT_TYPE
    ),
    gridengine=format_types_block(
        GridEngineBackend.CONFIG, GRIDENGINE_DEFAULT_TYPE
    ),
)

argparser = argparse.ArgumentParser(
    description=description,
    formatter_class=argparse.RawDescriptionHelpFormatter,
)


def kube_quant(string):
    """
    A type for args that roughly matches up with Kubernetes' quantity.go
    General form is <number><suffix>
    The following are acceptable suffixes

    base1024: Ki | Mi | Gi | Ti | Pi | Ei
    base1000: n | u | m | "" | k | M | G | T | P | E
    """
    valid_suffixes = [
        "Ki",
        "Mi",
        "Gi",
        "Ti",
        "Pi",
        "Ei",
        "n",
        "u",
        "m",
        "",
        "k",
        "M",
        "G",
        "T",
        "P",
        "E",
    ]
    pattern = re.compile(r"^(\d+)([A-Za-z]{0,2})$")
    quant_check = pattern.match(string)
    if quant_check:
        suffix = quant_check.group(2)
        if suffix in valid_suffixes:
            return string

    msg = "{} is not a valid Kubernetes quantity".format(string)
    raise argparse.ArgumentTypeError(msg)


argparser.add_argument("type", help="Type of webservice to start", nargs="?")
argparser.add_argument(
    "--backend",
    help="Which cluster backend to use run the webservice",
    choices=["gridengine", "kubernetes"],
)
argparser.add_argument(
    "-m",
    "--mem",
    required=False,
    type=kube_quant,
    help="Set higher Kubernetes memory limit (new cluster only)",
    dest="memory",
)
argparser.add_argument(
    "-c",
    "--cpu",
    required=False,
    type=kube_quant,
    help="Set a higher Kubernetes cpu limit (new cluster only)",
    dest="cpu",
)
argparser.add_argument(
    "action",
    help="Action to perform",
    choices=["start", "stop", "status", "restart", "shell"],
)
argparser.add_argument(
    "extra_args",
    help="Extra arguments to be parsed by the chosen webservicetype",
    nargs="?",
)
# Backwards compat with older webservice.
# Allows for webservice --release trusty lighttpd <action>
argparser.add_argument("--release", help=argparse.SUPPRESS, choices=["trusty"])


def start(job, message):
    try:
        job.request_start()
    except WebService.InvalidWebServiceException as e:
        raise SystemExit(e.message)
    # FIXME: Treat pending state differently.
    return wait_for(lambda: job.get_state() == Backend.STATE_RUNNING, message)


def stop(job, message):
    job.request_stop()
    return wait_for(lambda: job.get_state() == Backend.STATE_STOPPED, message)


def update_manifest(job, action, cpu, memory):
    """
    Update a tool's service manifest to indicate the type of webservice in use

    :param action 'start' or 'stop'
    :param cpu persists the cpu argument (must be a kube_quant)
    :param memory persists the mem argument (must be a kube_quant)
    """
    if action == "start":
        if (
            "web" not in job.tool.manifest
            or job.tool.manifest["web"] != job.type
        ):
            job.tool.manifest["distribution"] = platform.linux_distribution()[
                0
            ]
            job.tool.manifest["web"] = job.type
            if job.extra_args is not None:
                job.tool.manifest["web::extra_args"] = job.extra_args

            if hasattr(job, "container_resources"):
                # Not using the value directly to avoid persisting values from
                # the old Kubernetes cluster
                if cpu is not None:
                    job.tool.manifest["cpu"] = cpu
                if memory is not None:
                    job.tool.manifest["memory"] = memory

            job.tool.save_manifest()
    elif action == "stop":
        if "web" in job.tool.manifest:
            for key in [
                "distribution",
                "web",
                "backend",
                "cpu",
                "memory",
                "web::extra_args",
            ]:
                if key in job.tool.manifest:
                    del job.tool.manifest[key]
            job.tool.save_manifest()
    else:
        # blow up!
        raise Exception("action has to be 'start' or 'stop', got %s" % action)


if __name__ == "__main__":
    args = argparser.parse_args()

    tool = Tool.from_currentuser()

    # In order to more fully enable toolsbeta, we need to know we are there.
    if os.path.isfile("/etc/wmcs-project"):
        with open("/etc/wmcs-project") as f:
            project = f.readline().rstrip()

    # We use this logic rather than setting defaults in argparse.
    # This allows us to default to spec in service.manifest but override
    # by specifying --backend option on the CLI
    if args.backend is None:
        if (
            os.path.exists(os.path.expanduser("~/.webservicerc"))
            and "backend" not in tool.manifest
        ):
            config = ConfigParser()
            config.read(os.path.expanduser("~/.webservicerc"))
            backend = config.get("Default", "--backend")
        else:
            backend = tool.manifest.get("backend", "gridengine")
    else:
        if (
            "backend" in tool.manifest
            and tool.manifest["backend"] != args.backend
            and args.action != "shell"
        ):
            print(
                "Looks like you already have another webservice running, "
                "with a {} backend".format(tool.manifest["backend"])
            )
            print("You should stop that webservice by issuing:")
            print(
                "    webservice --backend=%s stop" % tool.manifest["backend"]
            )
            print(
                "And then start it again with backend %s by issuing:"
                % args.backend
            )
            print("    webservice --backend=%s start" % args.backend)
            sys.exit(1)
        backend = args.backend

    if backend == "gridengine":
        # Backwards compatibility hack to support
        # 'webservice --release trusty lighttpd start' invocations
        if args.release is not None:
            print("--release is deprecated and has no effect")
        if args.memory is not None:
            print("--mem is only for --backend=kubernetes and the new cluster")
            print("Please run again without this argument")
            sys.exit(1)
        if args.cpu is not None:
            print("--cpu is only for --backend=kubernetes and the new cluster")
            print("Please run again without this argument")
            sys.exit(1)
        if args.type is None:
            args.type = tool.manifest.get("web", GRIDENGINE_DEFAULT_TYPE)
        acceptable_types = GridEngineBackend.CONFIG.keys()
    elif backend == "kubernetes":
        if args.release is not None:
            print("--release is not implemented for --backend=kubernetes")
            print("Please just pick an appropriate type instead")
            sys.exit(1)
        if args.type is None:
            args.type = tool.manifest.get("web", KUBERNETES_DEFAULT_TYPE)

        if args.cpu is None:
            args.cpu = tool.manifest.get("cpu", None)

        if args.memory is None:
            args.memory = tool.manifest.get("memory", None)

        acceptable_types = KubernetesBackend.CONFIG.keys()

    if args.extra_args is None:
        args.extra_args = tool.manifest.get("web::extra_args", None)

    if args.type not in acceptable_types:
        print("type must be one of:")
        print(format_types_block(backend_clazz.CONFIG, ""))
        sys.exit(1)

    if backend == "gridengine":
        job = GridEngineBackend(tool, args.type, args.extra_args)
    else:
        job = KubernetesBackend(
            tool, project, args.type, args.memory, args.cpu, args.extra_args
        )

    tool.manifest["backend"] = backend

    if job.is_deprecated(args.type):
        print("DEPRECATED: '{}' type is deprecated.".format(args.type))
        print(
            "  See https://wikitech.wikimedia.org/wiki/Help:Toolforge/{}".format("Kubernetes" if backend == "kubernetes" else "Web")
        )
        print("  for currently supported types.")


    if args.action == "start":
        if job.get_state() != Backend.STATE_STOPPED:
            print("Your job is already running")
            sys.exit(1)

        start(job, "Starting webservice")
        update_manifest(job, "start", args.cpu, args.memory)

    elif args.action == "stop":
        if job.get_state() == Backend.STATE_STOPPED:
            print("Your webservice is not running", file=sys.stdout)
        else:
            stop(job, "Stopping webservice")
        update_manifest(job, "stop", args.cpu, args.memory)

    elif args.action == "restart":
        if job.get_state() != Backend.STATE_RUNNING:
            start(job, "Your job is not running, starting")
            update_manifest(job, "start", args.cpu, args.memory)
        else:
            job.request_restart()
        tool.save_manifest()

    elif args.action == "status":
        if job.get_state() != Backend.STATE_STOPPED:
            print(
                "Your webservice of type {} is running on backend {}".format(
                    job.type, backend),
                file=sys.stdout)
        else:
            print("Your webservice is not running", file=sys.stdout)

    elif args.action == "shell":
        if backend != "kubernetes":
            print("ERROR: shell is only supported for kubernetes backend")
            sys.exit(1)
        job.shell()
